# David Ding
# October 9th 2019
# Updated October 14th 2019
# This is a comprehensive package for the GENEActiv devices, starting from various types of data as input
# TODO: Include the wear/non-wear algorithms
# TODO: Include the reading for raw GENEActiv files as well as the processed versions (Mostly done, needs verification)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
import math
from scipy.signal import butter, lfilter
import peakutils
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()

# Subject IDs:
# From OND07
#   - 3028
#   - 3029
#   - 3031


class GENEActiv:
    """ This is the class for dealing with GENEActiv files

    Attributes:
        subj_id : int
            Unique subject code
        device_location : str
            Physical location of the GENEActiv device
        frequency : int
            Sample rate, measured in Hz
        start_time : datetime.datetime
            Start date and time in datetime format
        start_time_str : str
            Start date and time in string format
        time_shift : float
            GENEActiv recorded time shift as a float
        num_of_pages : int
            Number of pages in the recording
        remove_counter : float
            Number of counters before removing or adding a sample (used for time shift)
        hex_parsed : bool
            Whether or not the hexadecimal data has been parsed
        x : ndarray
            A 1D array containing the samples of the x-channel of the GENEActiv device, `float` data type
        y : ndarray
            A 1D array containing the samples of the y-channel of the GENEActiv device, `float` data type
        z : ndarray
            A 1D array containing the samples of the z-channel of the GENEActiv device, `float` data type
        svms : ndarray
            A 1D array containing the Sum of Vector magnitudes of the x, y, and z channels , `float` data type
        temps: ndarray
            A 1D array containing the temperature recordints, `float` data type
        times_generated : bool
            Whether or not the times array has been generated (not done by default since it is time consuming and
            not always necessary)


    Methods:

    """

    # Times and SVMs are are NOT generated by default due to the sheer length of time taken
    # However, they are allocated within the init function
    def __init__(self):
        """ Initialization function for the GENEActiv file """
        self.subj_id = None
        self.device_location = None
        self.frequency = None
        self.start_time = None
        self.start_time_str = None
        self.total_time_shift = None
        self.time_shift = None
        self.num_of_pages = None

        self.x_gain = None
        self.y_gain = None
        self.z_gain = None
        self.x_offset = None
        self.y_offset = None
        self.z_offset = None
        self.volts = None
        self.lux = None

        self.samples = None
        self.remove_counter = None

        self.hex_parsed = False
        self.x = np.array([])
        self.y = np.array([])
        self.z = np.array([])
        self.temps = np.array([])
        self.svms_generated = False
        self.svms = np.array([])
        self.times_generated = False
        self.times = np.array([])

        # Variables for finding head/tail peaks
        self.head = None
        self.tail = None
        self.filtered = None
        self.tail_indices = None
        self.head_indices = None

    def read_from_raw(self, path):
        """ Method that reads GENEActiv information that has not yet been parsed

        Args:
            path: str
                Contains the directory of the raw binary file

        Attributes:
            bin_file : file
                file object that reads data
            lines : ndarray
                1D array that stores the list of lines within the file
            header_packet : ndarray
                1D array that stores all the header information within the file
            data_packet : ndarray
                1D array that stores all the data after the main header

        Methods:
            parse_curr(x: str, output: file, iter: int, time: datetime.datetime, offsets: tuple, gains: tuple,
                   write_to_file=False) -> tuple
                Parses of the current line of hexadecimal

            twos_comp(val: float, bits: bit)
                Returns the numerical value of a twos compliment bitwise operation


        Returns:
            None

            Updates self with appropriate x, y, z, and temperature values

        """

        def twos_comp(val, bits):
            """ This method calculates the twos complement value of the current bit
            Args:
                val: bin
                    Bits to be processed (Binary)
                bits: int
                    Total number of bits in the operation

            Returns:
                Integer value resulting from the twos compliment operation
            """
            if (val & (1 << (bits - 1))) != 0:  # if sign bit is set e.g., 8bit: 128-255
                val = val - (1 << bits)  # compute negative value
            return val

        def process_curr(raw_hex, offsets, gains):
            """ This method processes the current line of "page" of data as defined by GENEActiv

            Args:
                raw_hex: str
                    String of Hexadecimal data to be parsed as per their descriptors
                offsets: tuple
                    Stores the offsets for the three channels in a tuple (x, y, z)
                gains: tuple
                    Stores the gains for the three channels in a tuple (x, y, z)

            Returns:
                list of tuples : Each tuple will contain (x, y, z) samples for that time

            """
            returned_array = []
            x_offset, y_offset, z_offset = offsets
            x_gain, y_gain, z_gain = gains

            for i in range(300):
                curr = bin(int(raw_hex[i * 12: (i + 1) * 12], 16))[2:]
                curr = curr.zfill(48)
                x_comp = curr[0:12]
                y_comp = curr[12:24]
                z_comp = curr[24:36]
                # light = curr[36:46]           # TODO: These variables are not used, not sure if they will be used
                # button = int(curr[46], 2)
                # res = int(curr[47], 2)

                # run the twos component value on each composition which starts in binary form
                x_comp = twos_comp(int(x_comp, 2), 12)
                y_comp = twos_comp(int(y_comp, 2), 12)
                z_comp = twos_comp(int(z_comp, 2), 12)

                # run the modifiers as prescribed in the GENEActiv documentation
                x_comp = (x_comp * 100 - x_offset) / x_gain
                y_comp = (y_comp * 100 - y_offset) / y_gain
                z_comp = (z_comp * 100 - z_offset) / z_gain

                returned_array.append((x_comp, y_comp, z_comp))

            return returned_array


        # Variable Declaration and Initialization
        lines = None
        header_packet = None
        data_packet = None
        bin_file = None
        header = {}

        # Getting input
        bin_file = open(path, "r", encoding="utf-8")
        lines = np.array([line[:-1] for line in bin_file.readlines()])
        bin_file.close()

        # Parsing Input
        header_packet = lines[:59]
        data_packet = lines[59:]

        # Getting Data from the header
        for line in header_packet:
            try:
                colon = line.index(":")
                header[line[:colon]] = (line[colon + 1:].rstrip('\x00').rstrip())
            except ValueError:
                pass

        # Extracting and saving relevant information from header dictionary
        self.subj_id = int(header["Subject Code"])
        self.device_location = header["Device Location"]
        self.frequency = header["Measurement Frequency"]
        self.start_time_str = header["Start Time"]
        self.start_time = datetime.datetime.strptime(self.start_time_str, "%Y-%m-%d %H:%M:%S:%f")
        self.time_shift = float(header["Extract Notes"].split(" ")[-1][:-2])
        self.total_time_shift = self.time_shift
        self.num_of_pages = int(header["Number of Pages"])

        self.x_gain = float(header["x gain"])
        self.y_gain = float(header["y gain"])
        self.z_gain = float(header["z gain"])

        self.x_offset = float(header["x offset"])
        self.y_offset = float(header["y offset"])
        self.z_offset = float(header["z offset"])

        self.samples = self.num_of_pages * 300
        self.remove_counter = 0

        # Appending relevant information from parsed hexadecimal data
        for i in range(self.num_of_pages):
            curr_chunk = process_curr(data_packet[(i*10) + 9], (self.x_offset, self.y_offset, self.z_offset),
                                      (self.x_gain, self.y_gain, self.z_gain))
            self.temps = np.append(self.temps, float(data_packet[(i * 10) + 5].split(":")[-1]))
            self.x = np.append(self.x, [curr_chunk[j][0] for j in range(300)])
            self.y = np.append(self.y, [curr_chunk[j][1] for j in range(300)])
            self.z = np.append(self.z, [curr_chunk[j][2] for j in range(300)])

    def read_from_processed(self, dfrow, path):
        """ Method that reads GENEActiv information from already parsed and processed data

        Parameters
        ----------
        dfrow : pandas.Series
            Series object parsed from the Folder Summary CSV files
        path : str
            String containing location to the input x, y, z and temperature files

        """
        # Header Information
        self.subj_id = dfrow.SubjectID
        self.device_location = dfrow.DeviceLocation
        self.frequency = dfrow.Frequency
        self.start_time = dfrow.StartTime
        self.start_time_str = datetime.datetime.strptime(self.start_time, "%Y-%m-%d %H:%M:%S.%f")
        self.time_shift = float(dfrow.ExtractNotes.split(" ")[-1][:-2])
        self.total_time_shift = self.time_shift
        self.num_of_pages = dfrow.NumOfPages

        # Calibration information
        self.x_offset = dfrow["X-offset"]
        self.y_offset = dfrow["Y-offset"]
        self.z_offset = dfrow["Z-offset"]

        self.x_gain = dfrow["X-gain"]
        self.y_gain = dfrow["Y-gain"]
        self.z_gain = dfrow["Z-gain"]

        # Information for Processing
        self.samples = self.num_of_pages * 300
        self.remove_counter = 0

        # Raw Data
        self.hex_parsed = True
        self.x = np.fromfile(path + "%i_%s_x-channel.bin" % (self.subj_id, self.device_location))
        self.y = np.fromfile(path + "%i_%s_x-channel.bin" % (self.subj_id, self.device_location))
        self.z = np.fromfile(path + "%i_%s_x-channel.bin" % (self.subj_id, self.device_location))
        self.temps = np.fromfile(path + "%i_%s_x-channel.bin" % (self.subj_id, self.device_location))
        self.times_generated = False
        self.times = None

    def calculate_svms(self):
        self.svms_generated = True
        self.svms = np.array([math.sqrt(math.pow(self.x[i], 2) + math.pow(self.y[i], 2) + math.pow(self.z[i], 2)) - 1
                             for i in range(len(self.x))])

    def generate_time(self):
        self.times = np.array([self.start_time + datetime.timedelta(seconds=(i / self.frequency))
                               for i in range(len(self.x))])
        self.times_generated = False

    def modify_time_shift(self, amount):
        self.total_time_shift += amount
        self.time_shift = amount
        self.calculate_time_shift()

    def calculate_time_shift(self):
        self.remove_counter = abs(self.samples / (self.time_shift * self.frequency))
        if self.time_shift > 0:
            # We need to remove every nth value (n = remove_counter)
            self.x = np.delete(self.x,
                               [(self.remove_counter * i) for i in range(int(len(self.x) / self.remove_counter))])
            self.y = np.delete(self.y,
                               [(self.remove_counter * i) for i in range(int(len(self.y) / self.remove_counter))])
            self.z = np.delete(self.z,
                               [(self.remove_counter * i) for i in range(int(len(self.z) / self.remove_counter))])
        else:
            # We need to add a 0 value every remove_counter indices
            self.x = np.insert(self.x,
                               [(self.remove_counter * i) for i in range(int(len(self.x) / self.remove_counter))], 0)
            self.y = np.insert(self.y,
                               [(self.remove_counter * i) for i in range(int(len(self.y) / self.remove_counter))], 0)
            self.z = np.insert(self.z,
                               [(self.remove_counter * i) for i in range(int(len(self.z) / self.remove_counter))], 0)



    def find_tail_peaks(self, first_lowcut=0.5, first_highcut=1.5, first_filtorder=4,
                   second_lowcut=0.5, second_filtorder=4):

        def bandpass_filter(dataset, lowcut, highcut, signal_freq, filter_order):
            """Method that creates bandpass filter to ECG data."""

            # Filter characteristics
            nyquist_freq = 0.5 * signal_freq
            low = lowcut / nyquist_freq
            high = highcut / nyquist_freq
            b, a = butter(filter_order, [low, high], btype="band")
            y = lfilter(b, a, dataset)
            return y

        def lowpass_filter(dataset, lowcut, signal_freq, filter_order):
            nyq = 0.5 * signal_freq
            low = lowcut / nyq
            b, a = butter(filter_order, low, btype="lowpass")
            y = lfilter(b, a, dataset)
            return y
        if self.svms_generated:
            self.tail = self.svms[-135000:]
            self.filtered = abs(bandpass_filter(self.tail, first_lowcut, first_highcut, self.frequency, first_filtorder))
            self.filtered = lowpass_filter(self.filtered, second_lowcut, self.frequency, second_filtorder)

            self.tail_indices = peakutils.indexes(self.filtered, thres=0.75, min_dist=4500)
        else:
            print("========== ERROR: SVMs not yet calculated ==========")


class Subject:
    def __init__(self, subjectID):
        self.id = subjectID
        self.LA = GENEActiv()
        self.LW = GENEActiv()
        self.RA = GENEActiv()
        self.RW = GENEActiv()

    def read_from_processed(self, path, path_to_df, LA=True, LW=True, RA=True, RW=True, time_shift=True):
        """ This function initializes the Subject's GENEActiv devices from processed numpy.tofile files

        Args:
            subjectID: int
                Unique Subject Code to analyze
            path: str
                Path to where the processed files are stored
            path_to_df: str
                Path to the dataframe
            LA: bool
                Whether or not to load the Left Ankle file
            LW: bool
                Whether or not to load the Left Wrist file
            RA: bool
                Whether or not to load the Right Ankle file
            RW: bool
                Whether or not to load the Right Wrist file
            time_shift: bool
                Whether or not to calculate time shift based on GENEActiv device

        Returns:

        """
        self.df = pd.read_csv(path_to_df)
        self.df = self.df[self.df["SubjectID"] == self.id].reset_index(level=0)

        if LA:
            self.LA.read_from_processed(self.df.loc[0], path)
        if LW:
            self.LW.read_from_processed(self.df.loc[1], path)
        if RA:
            self.RA.read_from_processed(self.df.loc[2], path)
        if RW:
            self.RW.read_from_processed(self.df.loc[3], path)

        # This accounts for time shift as per the GENEActiv device itself
        if time_shift:
            self.LA.calculate_time_shift()
            self.RA.calculate_time_shift()
            self.LW.calculate_time_shift()
            self.RW.calculate_time_shift()

    def read_from_bin(self, LA=True, LW=True, RA=True, RW=True, time_shift=True):
        """

        Args:
            subjectID: int
                Current Subject ID
            LA: bool
                Whether or not to load Left Ankle file
            LW: bool
                Whether or not to load the Left Wrist file
            RA: bool
                Whether or not to load the Right Ankle file
            RW: bool
                Whether or not to load the Right Wrist file
            time_shift:
                Whether or not to account for time shift as per the GENEActiv device

        Returns:

        """
        if LA:
            path = input("Please enter full file path to Left Ankle File: ")
            self.LA.read_from_raw(path)
        if LW:
            path = input("Please enter full file path to Left Wrist File: ")
            self.LW.read_from_raw(path)
        if RA:
            path = input("Please enter full file path to Right Ankle File: ")
            self.RA.read_from_raw(path)
        if RW:
            path = input("Please enter full file path to Right Wrist File: ")
            self.RW.read_from_raw(path)

        if time_shift:
            self.LA.calculate_time_shift()
            self.RA.calculate_time_shift()
            self.LW.calculate_time_shift()
            self.RW.calculate_time_shift()

    def calculate_svms(self):
        self.LA.calculate_svms()
        self.LW.calculate_svms()
        self.RA.calculate_svms()
        self.RW.calculate_svms()

    def plot_x(self):
        """ This function plots all x-channels from the accelerometers
        TODO: Implement plotting for only select number of channels
        TODO: Implement plotting for different channels (user-specified params)
        """
        fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 8), sharex=True, sharey=True)
        fig.suptitle("%i" % self.id)
        if self.LA.times_generated and self.RA.times_generated and self.RW.times_generated and self.RA.times_generated:
            ax1.plot(self.LA.times, self.LA.x, linewidth=0.5)
            ax1.set_title("Left Ankle")

            ax2.plot(self.LW.times, self.LW.x, linewidth=0.5)
            ax2.set_title("Left Wrist")

            ax3.plot(self.RA.times, self.RA.x, linewidth=0.5)
            ax3.set_title("Right Ankle")

            ax4.plot(self.RW.times, self.RW.x, linewidth=0.5)
            ax4.set_title("Right Wrist")
        else:
            ax1.plot(self.LA.x, linewidth=0.5)
            ax1.set_title("Left Ankle")

            ax2.plot(self.LW.x, linewidth=0.5)
            ax2.set_title("Left Wrist")

            ax3.plot(self.RA.x, linewidth=0.5)
            ax3.set_title("Right Ankle")

            ax4.plot(self.RW.x, linewidth=0.5)
            ax4.set_title("Right Wrist")

            if not self.LA.times_generated:
                print("Left ankle times not generated")
            if not self.LW.times_generated:
                print("Left wrist times not generated")
            if not self.RA.times_generated:
                print("Right ankle times not generated")
            if not self.RW.times_generated:
                print("Right wrist times not generated")

    def plot_time_discrepancy(self):
        self.LA.find_tail_peaks()
        self.LW.find_tail_peaks()
        self.RA.find_tail_peaks()
        self.RW.find_tail_peaks()

        fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 8), sharex=True, sharey=True)

        ax1.plot(self.LA.tail)
        ax2.plot(self.LW.tail)
        ax3.plot(self.RA.tail)
        ax4.plot(self.RW.tail)

        for peak in self.LA.tail_indices:
            ax1.axvline(peak, -10, 10, c="red")
        for peak in self.LW.tail_indices:
            ax2.axvline(peak, -10, 10, c="red")
        for peak in self.RA.tail_indices:
            ax3.axvline(peak, -10, 10, c="red")
        for peak in self.RW.tail_indices:
            ax4.axvline(peak, -10, 10, c="red")



input_path = "/Users/nimbal/Documents/OND07/ProcessedBIN/"
output_path = "/Users/nimbal/Documents/OND07/ProcessedBIN/"
path_to_df = "/Users/nimbal/Documents/OND07/Summary/Summary.csv"


curr_subject_ID = int(input("Please enter subject ID to analyze: "))

subject = Subject(curr_subject_ID)
# subject.read_from_processed(input_path, path_to_df)



